from jax import numpy as np
import jax
jax.config.update("jax_platform_name", "cpu")
jax.config.update('jax_enable_x64', True)
import pennylane as qml

""" The Variational Quantum Eigensolver (VQE) is a flagship algorithm for quantum chemistry 
using near-term quantum computers [1]. It is an application of the Ritz variational 
principle, where a quantum computer is trained to prepare the ground state of a given 
molecule.


The inputs to the VQE algorithm are a molecular Hamiltonian and a parametrized 
circuit preparing the quantum state of the molecule. 
Within VQE, the cost function is defined as the expectation value of the Hamiltonian
computed in the trial state. The ground state of the target Hamiltonian is
obtained by performing an iterative minimization of the cost function. 
The optimization is carried out by a classical optimizer which leverages a 
quantum computer to evaluate the cost function and calculate its gradient 
at each optimization step.
 """
symbols = ["H", "H"]
coordinates = np.array([[-0.70108983, 0.0, 0.0], [0.70108983, 0.0, 0.0]])
molecule = qml.qchem.Molecule(symbols, coordinates)
H, qubits = qml.qchem.molecular_hamiltonian(molecule)

""" The outputs of the function are the Hamiltonian, represented as a linear combination 
of Pauli operators, and the number of qubits required for the quantum simulations. 
For this example, we use a minimal basis set to represent the molecular orbitals. 
In this approximation, we have four spin orbitals, which defines the number of qubits. 
Furthermore, we use the Jordan-Wigner transformation [2] to perform the 
fermionic-to-qubit mapping of the Hamiltonian. """

print("Number of qubits = ", qubits)
print("The Qubit Hamiltonian is ", H)

dev = qml.device("lightning.qubit", wires=qubits)

electrons = 2
""" In the HF approximation, each electron in the molecule is treated as an 
independent particle that moves under the influence of the Coulomb potential 
due to the nuclei, and a mean field generated by all other electrons.  """
hf = qml.qchem.hf_state(electrons, qubits)
print("The initial HF state is given as: ", hf)

""" The hf array is used by the BasisState operation to initialize the qubit register. 
Then, we just act with the DoubleExcitation operation on the four qubits. 
The next step is to compute the expectation value of the molecular Hamiltonian 
in the trial state prepared by the circuit. We do this using the expval() function. 
The decorator syntax allows us to run the cost function as an executable QNode with 
the gate parameter theta  """

@qml.qnode(dev, interface="jax")
def circuit(param, wires):
    qml.BasisState(hf, wires=wires)
    qml.DoubleExcitation(param, wires=[0, 1, 2, 3])
    return qml.expval(H)

# We can now define our error function simply as the expected value calculated above (which is the 
# expectation value of the Energy)
def cost_fn(param):
    return circuit(param, wires=range(qubits))


import optax
# We use a classical orptimizer 
max_iterations = 100
conv_tol = 1e-06
opt = optax.sgd(learning_rate=0.4)
# We initialize the circuit parameter to zero, meaning that we start from the Hartree-Fock state.
theta = np.array(0.)
# store the values of the cost function
energy = [cost_fn(theta)]
# store the values of the circuit parameter
angle = [theta]
opt_state = opt.init(theta)

for n in range(max_iterations):

    gradient = jax.grad(cost_fn)(theta)
    updates, opt_state = opt.update(gradient, opt_state)
    theta = optax.apply_updates(theta, updates)

    angle.append(theta)
    energy.append(cost_fn(theta))

    conv = np.abs(energy[-1] - energy[-2])
    if n % 2 == 0:
        print(f"Step = {n},  Energy = {energy[-1]:.8f} Ha")
    if conv <= conv_tol:
        break

print("\n" f"Final value of the ground-state energy = {energy[-1]:.8f} Ha")
print("\n" f"Optimal value of the circuit parameter = {angle[-1]:.4f}")

import matplotlib.pyplot as plt

fig = plt.figure()
fig.set_figheight(5)
fig.set_figwidth(12)
ax1 = fig.add_subplot(121)
ax1.plot(range(n + 2), energy, "go", ls="dashed")
ax1.set_xlabel("Optimization step", fontsize=13)
ax1.set_ylabel("Energy (Hartree)", fontsize=13)
ax1.text(0.5, -1.1176, r"$E_\mathrm{HF}$", fontsize=15)
ax1.text(0, -1.1357, r"$E_\mathrm{FCI}$", fontsize=15)
plt.xticks(fontsize=12)
plt.yticks(fontsize=12)

ax2 = fig.add_subplot(122)
ax2.plot(range(n + 2), angle, "go", ls="dashed")
ax2.set_xlabel("Optimization step", fontsize=13)
ax2.set_ylabel("Gate parameter $\\theta$ (rad)", fontsize=13)
plt.xticks(fontsize=12)
plt.yticks(fontsize=12)
plt.subplots_adjust(wspace=0.3, bottom=0.2)
plt.show()